
uniform mat4 iNormalMatrix;

uniform int iUseTexture0;
uniform int iUseTexture1;
uniform int iUseTexture2;
uniform int iUseTexture3;

uniform sampler2D iTexture0;
uniform sampler2D iTexture1;
uniform sampler2D iTexture2;
uniform sampler2D iTexture3;

uniform vec4 iClipPlane;
uniform int iUseClipPlane;
uniform vec4 iClipSphere;
uniform int iUseClipSphere;
uniform int iUseLighting;
uniform int iMultiplyAmbient;
uniform int iUseTiles;
uniform float iGlobalTime;

//fog-related uniforms
uniform int iFogEnabled;
uniform int iFogMode; //0 - linear, 1 - exp, 2 - exp2
uniform float iFogDensity;
uniform float iFogStart;
uniform float iFogEnd;
uniform vec3 iFogCol;
uniform vec3 iPlayerPosition;

varying vec3 iNormal;
varying vec3 iNormalWorld;
varying vec3 iNormalCamera;
varying vec3 iPosition;
varying vec3 iPositionWorld;
varying vec3 iPositionCamera;
varying vec3 iTangent;
varying vec3 iBitangent;

void main()
{

  //clipping plane part of shader
  if (iUseClipPlane == 1 && dot(iPositionWorld, iClipPlane.xyz) < iClipPlane.w) {
    discard;
  } 

  if (iUseClipSphere == 1 && dot(iPositionWorld-iClipSphere.xyz, iPositionWorld-iClipSphere.xyz) > iClipSphere.w * iClipSphere.w) {
    discard;
  }
 
   vec3 N = normalize(iNormalWorld);
   vec3 E = normalize(iPlayerPosition+vec3(0,1.6,0) - iPositionWorld); 
   //vec3 L = normalize(vec3(0, sin(iGlobalTime), cos(iGlobalTime)));
   vec3 L = normalize(vec3(E.x, E.y, E.z));
      
  //normal mapping component
  if (iUseTexture2 == 1) {
    vec3 normalTexel = texture2D(iTexture2, gl_TexCoord[0].xy).rgb;     // Fetch object space normal [0.0,1.0] range per channel
    normalTexel = normalTexel*255.0/128.0-1.0;     // Convert normal into [-1.0, 1.0] range per channel
    normalTexel = (iNormalMatrix * vec4(iTangent * normalTexel.r + iBitangent * normalTexel.g + iNormal * normalTexel.b, 0.0)).xyz;
    N = normalize(normalTexel);
  }   

  vec3 R = normalize(reflect(-L, N));

  vec4 ambient = vec4(1,1,1,1);
  vec4 diffuse = vec4(1,1,1,1);
  vec4 specular = vec4(0,0,0,1);   

  //diffuse component
  if (iUseTexture0 == 1) {
    diffuse = texture2D(iTexture0, gl_TexCoord[0].xy);
  }
  else {
    diffuse = gl_FrontMaterial.diffuse;
  }
  if (iUseLighting == 1) {
    diffuse.xyz *= 0.8 * max(dot(N, L), 0.0) + 0.2;
  }

  //ambient component
  if (iUseTexture1 == 1) {
    ambient = texture2D(iTexture1, gl_TexCoord[1].xy);
  } 

  if(ambient.w < 0.05 || diffuse.w < 0.05) {
    discard;
  }

  //ambient.w = 1.0;

  //specular component - note disabled if "lighting" is off
  if (iUseLighting == 1) {
    //specular = gl_FrontMaterial.specular;
    if (iUseTexture3 == 1) {
      specular *= texture2D(iTexture3, gl_TexCoord[0].xy);
    }       
    else {
      specular *= pow(max(dot(R,E),0.0), max(gl_FrontMaterial.shininess, 1.0));
    }
  }  
  specular.w = 1.0;

  //global scaling via colour
  gl_FragColor = gl_Color;
  gl_FragColor.xyz *= (ambient * (diffuse + specular)).xyz;  

  if (iUseTexture0 == 1) {
    gl_FragColor.w *= diffuse.w;
  }

  //tiling part of shader
  if (iUseTiles == 1) {
	vec3 vecx = vec3(1, 0, 0);
	if (abs(dot(vecx, iNormal)) > 0.9) {
		vecx = vec3(0, 1, 0);
	}

	vec3 vecy = cross(iNormal, vecx);
	vecx = cross(vecy, iNormal);

	float x_col = mod(dot(iPosition, vecx) - 0.5, 1.0);
	float y_col = mod(dot(iPosition, vecy) - 0.5, 1.0);
	float max_alpha = 1.0;

	int count = 0;
	if (x_col > 0.45 && x_col < 0.55) {
		max_alpha=min(abs(x_col-0.5), max_alpha);
	}
	if (y_col > 0.45 && y_col < 0.55) {
		max_alpha=min(abs(y_col-0.5), max_alpha);
	}
	
	float len = clamp(length(iPlayerPosition - iPosition) / 20.0, 0.0, 1.0);
	float tile_black = 0.5 + 0.5 * clamp(max_alpha * 20.0 + len, 0.0, 1.0);
		
	gl_FragColor.xyz *= tile_black;	
  }

  //apply fog
  if (iFogEnabled == 1) {

    //compute length from eye to fragment
    float c = length(iPositionCamera);   

    //compute blend value
    float f;
    if (iFogMode == 0) {
      f = (iFogEnd - c) / (iFogEnd - iFogStart);
    }
    else if (iFogMode == 1) {
      f = exp(-iFogDensity * c);
    }
    else {
      f = exp(-(iFogDensity * c)*(iFogDensity * c));
    }
    f = clamp(f, 0.0, 1.0);   

    //blend with fragment's post-texturing colour using the appropriate blending factor
    gl_FragColor.xyz = gl_FragColor.xyz * f + iFogCol * (1.0 - f);

  }

  //apply temporal noise, avoids gradients 
  float dotVal = dot(vec2(171.0, 231.0), gl_FragCoord.xy + iGlobalTime);
  vec3 vDither = vec3(dotVal, dotVal, dotVal); 
  vDither = fract(vDither / vec3(103.0,71.0,97.0)) - vec3(0.5, 0.5, 0.5); 
  gl_FragColor.xyz += vDither.xyz * 0.015;
}
