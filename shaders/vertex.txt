#version 120

//inputs
uniform mat4 iModelMatrix;
uniform mat4 iNormalMatrix;  //Note: this is transpose(inverse(iModelMatrix)) 
uniform mat4 iViewMatrix;
uniform mat4 iViewMatrixInverse;
uniform int iUseTexture0;
uniform int iUseTexture1;
uniform int iUseTexture2;
uniform int iUseTexture3;
uniform sampler2D iTexture0;
uniform sampler2D iTexture1;
uniform sampler2D iTexture2;
uniform sampler2D iTexture3;
uniform samplerCube iCubeTexture0;
uniform int iUseClipPlane;
uniform int iUseLighting;
uniform int iIllum;
uniform vec4 iClipPlane;                                    

//blend shape support
uniform float iBlend0;
uniform float iBlend1;
uniform float iBlend2;
uniform float iBlend3;
attribute vec3 iBlendV0;
attribute vec3 iBlendV1;
attribute vec3 iBlendV2;
//attribute vec3 iBlendV3; //problems with max # attributes if this is enabled
attribute vec3 iBlendN0;
attribute vec3 iBlendN1;
attribute vec3 iBlendN2;
//attribute vec3 iBlendN3; //problems with max # attributes if this is enabled

//GPU-based skeletal animation support
const int MAX_JOINTS = 128;
uniform int iUseSkelAnim;
uniform mat4 iSkelAnimJoints[MAX_JOINTS];
attribute vec4 iSkelAnimIndexes;
attribute vec4 iSkelAnimWeights;
attribute vec3 iVertexTangent;

//outputs
varying vec3 iPosition;
varying vec3 iPositionWorld;
varying vec3 iPositionCamera;
varying vec3 iNormal;
varying vec3 iNormalWorld;
varying vec3 iNormalCamera;
varying vec3 iTangent;
varying vec3 iBitangent;

void main(void) {

  vec3 blend_pos = gl_Vertex.xyz;
  vec3 blend_norm = gl_Normal;

  //skeletal animation
  if (iUseSkelAnim == 1) {
    int index = int(iSkelAnimIndexes.x);     
    if (index >= 0) {
	blend_pos = (iSkelAnimJoints[index] * gl_Vertex).xyz * iSkelAnimWeights.x;
	blend_norm = (iSkelAnimJoints[index] * vec4(gl_Normal, 0.0)).xyz * iSkelAnimWeights.x;
    }
       
    index = int(iSkelAnimIndexes.y);        
    if (index >= 0) {
    	blend_pos += (iSkelAnimJoints[index] * gl_Vertex).xyz * iSkelAnimWeights.y;
        blend_norm += (iSkelAnimJoints[index] * vec4(gl_Normal, 0.0)).xyz * iSkelAnimWeights.y;
    }

    index = int(iSkelAnimIndexes.z);        
    if (index >= 0) {
        blend_pos += (iSkelAnimJoints[index] * gl_Vertex).xyz * iSkelAnimWeights.z;
        blend_norm += (iSkelAnimJoints[index] * vec4(gl_Normal, 0.0)).xyz * iSkelAnimWeights.z;
    }

    index = int(iSkelAnimIndexes.w);        
    if (index >= 0) {
        blend_pos += (iSkelAnimJoints[index] * gl_Vertex).xyz * iSkelAnimWeights.w;
        blend_norm += (iSkelAnimJoints[index] * vec4(gl_Normal, 0.0)).xyz * iSkelAnimWeights.w;
    }
  }
  else {    
    blend_pos += (iBlendV0 - gl_Vertex.xyz) * iBlend0;
    blend_norm += (iBlendN0 - gl_Normal.xyz) * iBlend0;

    blend_pos += (iBlendV1 - gl_Vertex.xyz) * iBlend1;
    blend_norm += (iBlendN1 - gl_Normal.xyz) * iBlend1;

    blend_pos += (iBlendV2 - gl_Vertex.xyz) * iBlend2;
    blend_norm += (iBlendN2 - gl_Normal.xyz) * iBlend2;

    //blend_pos += (iBlendV3 - gl_Vertex.xyz) * iBlend3;
    //blend_norm += (iBlendN3 - gl_Normal.xyz) * iBlend3;
  } 

  iPosition = blend_pos.xyz;
  iNormal = normalize(blend_norm);
  iPositionWorld = (iModelMatrix * vec4(blend_pos, 1)).xyz;  
  iPositionCamera = (gl_ModelViewMatrix * vec4(blend_pos, 1)).xyz;   
  iNormalWorld = (iNormalMatrix * vec4(iNormal, 0.0)).xyz;  
  iNormalCamera = gl_NormalMatrix * iNormal;   //iNormalCamera = gl_NormalMatrix * gl_Normal;
  iTangent = iVertexTangent.xyz;
  iBitangent = cross(iNormal, iTangent); //w component of input tangent stores orientation scaling value
  gl_Position = gl_ModelViewProjectionMatrix * vec4(blend_pos, 1);  
  gl_FrontColor = gl_Color;
  gl_TexCoord[0] = gl_MultiTexCoord0;
  gl_TexCoord[1] = gl_MultiTexCoord1;
  gl_TexCoord[2] = gl_MultiTexCoord2;
  gl_TexCoord[3] = gl_MultiTexCoord3;

}
